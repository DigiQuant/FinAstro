# -*- coding: utf-8 -*-
# Kerykeion v3.x compatible
from kerykeion import AstrologicalSubject, Report # Report is now primary for chart details
from datetime import datetime, timezone, timedelta
import math
import pprint
import inspect
try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
    _use_zoneinfo = True
except ImportError:
    _use_zoneinfo = False
    try:
        import pytz
        _use_pytz = True
    except ImportError:
        _use_pytz = False
import traceback

# --- Zodiac Rulers for House Lord Calculations ---
# This WILL be used by the custom print_derived_house_lords function
ZODIAC_RULERS = {
    "Ari": "Mars", "Tau": "Venus", "Gem": "Mercury", "Can": "Moon",
    "Leo": "Sun", "Vir": "Mercury", "Lib": "Venus", "Sco": "Mars",
    "Sag": "Jupiter", "Cap": "Saturn", "Aqu": "Saturn", "Pis": "Jupiter"
}

# --- Configuration (Combined) ---
# Using S&P500 Natal and Apr 1, 2025 Transit from previous examples
natal_name = "S&P500"; natal_year = 1957; natal_month = 3; natal_day = 4; natal_hour_local = 9; natal_minute_local = 30
transit_name = "Transit Chart (Apr 3, 2025)"; transit_year = 2025; transit_month = 4; transit_day = 3; transit_hour_local = 9; transit_minute_local = 30

location_city = "New York"; location_nation = "US"; location_latitude = 40.7128; location_longitude = -74.0060; location_timezone_str = "America/New_York"
ayanamsa = "LAHIRI"; house_system_identifier = "S"; zodiac_type = "Sidereal" # Using Sripathi 'S'
house_system_names = { "P": "Placidus", "K": "Koch", "R": "Regiomontanus", "C": "Campanus", "E": "Equal", "W": "Whole Sign", "X": "Axial Rotation System", "H": "Horizontal System", "T": "Polich/Page (Topocentric)", "B": "Alcabitus", "M": "Morinus", "U": "Krusinski-Pisa-Goelzer", "S": "Sripathi" }
house_system_name = house_system_names.get(house_system_identifier, f"Unknown ({house_system_identifier})")
KERYKEION_ONLINE_MODE = False # Set to False for local calculation

# --- Aspect Configuration ---
ASPECTS_TO_CHECK = [0, 60, 90, 120, 180]
ASPECT_NAMES = { 0: "Conjunct", 60: "Sextile", 90: "Square", 120: "Trine", 180: "Opposite"}
MAX_ASPECT_ORB = 5.0
STATIONARY_SPEED_THRESHOLD = 1e-6

# --- Planet/Point Configuration (Simplified as custom report removed) ---
EXPECTED_BODIES_FOR_SPEED = [
    'sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn',
    'uranus', 'neptune', 'pluto', 'mean_node', 'true_node', 'true_south_node'
]
PLANETS_FOR_SPEED_TABLE = [
    "Sun", "Moon", "Mercury", "Venus", "Mars", "Jupiter", "Saturn",
    "Uranus", "Neptune", "Pluto", "True Node", "True S. Node"
]
PLANETS_FOR_ASPECTS = [
    "Sun", "Moon", "Mercury", "Venus", "Mars", "Jupiter",
    "Saturn", "Uranus", "Neptune", "Pluto", "Ascendant",
    "True Node"
]
PLANET_ATTRIBUTE_MAP = {
    'sun': 'Sun', 'moon': 'Moon', 'mercury': 'Mercury', 'venus': 'Venus',
    'mars': 'Mars', 'jupiter': 'Jupiter', 'saturn': 'Saturn', 'uranus': 'Uranus',
    'neptune': 'Neptune', 'pluto': 'Pluto', 'mean_node': 'Mean_Node',
    'true_node': 'True Node', 'chiron': 'Chiron', 'mean_lilith': 'Mean_Lilith',
    'ascendant': 'Ascendant', 'mc': 'MC',
    'medium_coeli': 'MC',
    'true_south_node': 'True S. Node'
}
ATTRIBUTE_PLANET_MAP = {v: k for k, v in PLANET_ATTRIBUTE_MAP.items()} # Still needed for speeds/aspects
SIGN_START_LONGITUDES = { "Ari": 0.0, "Tau": 30.0, "Gem": 60.0, "Can": 90.0, "Leo": 120.0, "Vir": 150.0, "Lib": 180.0, "Sco": 210.0, "Sag": 240.0, "Cap": 270.0, "Aqu": 300.0, "Pis": 330.0 } # Still needed for speeds/aspects

# --- Timezone Helper Function ---
def get_utc_datetime(year, month, day, hour, minute, tz_str):
    if _use_zoneinfo:
        try: local_tz = ZoneInfo(tz_str); local_dt = datetime(year, month, day, hour, minute, tzinfo=local_tz); utc_dt = local_dt.astimezone(timezone.utc); return utc_dt
        except ZoneInfoNotFoundError: print(f"Error: Timezone '{tz_str}' not found by zoneinfo."); return None
        except Exception as e_zi: print(f"Error: zoneinfo error for {year}-{month}-{day} {hour}:{minute} in {tz_str}: {e_zi}"); return None
    elif _use_pytz:
        try: local_tz = pytz.timezone(tz_str); local_dt = datetime(year, month, day, hour, minute); local_dt_aware = local_tz.localize(local_dt, is_dst=None); utc_dt = local_dt_aware.astimezone(pytz.utc); return utc_dt
        except pytz.exceptions.UnknownTimeZoneError: print(f"Error: Timezone '{tz_str}' not found by pytz."); return None
        except pytz.exceptions.AmbiguousTimeError: print(f"Error: Ambiguous time encountered for {year}-{month}-{day} {hour}:{minute} in {tz_str}. Try adjusting the time slightly."); return None
        except pytz.exceptions.NonExistentTimeError: print(f"Error: Non-existent time encountered for {year}-{month}-{day} {hour}:{minute} in {tz_str} (likely during DST spring-forward). Try adjusting the time."); return None
        except Exception as e_pytz: print(f"Error: pytz error for {year}-{month}-{day} {hour}:{minute} in {tz_str}: {e_pytz}"); return None
    else: print("Error: Neither zoneinfo nor pytz is available for timezone handling."); return None

# --- NAKSHATRA DATA AND FUNCTIONS ---
NAKSHATRA_BOUNDARIES = [
    {"Name": "Ashwini", "Start": 0.0, "End": 13.3333, "Ruler": "Ketu", "Weight": 1.3, "Trend": "Bullish"}, {"Name": "Bharani", "Start": 13.3333, "End": 26.6667, "Ruler": "Venus", "Weight": 0.9, "Trend": "Bullish"}, {"Name": "Krittika", "Start": 26.6667, "End": 40.0, "Ruler": "Sun", "Weight": 0.7, "Trend": "Bullish"}, {"Name": "Rohini", "Start": 40.0, "End": 53.3333, "Ruler": "Moon", "Weight": 3.5, "Trend": "Strong Bullish"}, {"Name": "Mrigashira", "Start": 53.3333, "End": 66.6667, "Ruler": "Mars", "Weight": 1.0, "Trend": "Bullish"}, {"Name": "Ardra", "Start": 66.6667, "End": 80.0, "Ruler": "Rahu", "Weight": 0.5, "Trend": "Strong Bearish"}, {"Name": "Punarvasu", "Start": 80.0, "End": 93.3333, "Ruler": "Jupiter", "Weight": 1.1, "Trend": "Bullish"}, {"Name": "Pushya", "Start": 93.3333, "End": 106.6667, "Ruler": "Saturn", "Weight": 4.0, "Trend": "Strong Bullish"}, {"Name": "Ashlesha", "Start": 106.6667, "End": 120.0, "Ruler": "Mercury", "Weight": 1.1, "Trend": "Bearish"}, {"Name": "Magha", "Start": 120.0, "End": 133.3333, "Ruler": "Ketu", "Weight": 0.5, "Trend": "Slightly Bullish"}, {"Name": "Purva Phalguni", "Start": 133.3333, "End": 146.6667, "Ruler": "Venus", "Weight": 1.2, "Trend": "Bullish"}, {"Name": "Uttara Phalguni", "Start": 146.6667, "End": 160.0, "Ruler": "Sun", "Weight": 1.1, "Trend": "Bullish"}, {"Name": "Hasta", "Start": 160.0, "End": 173.3333, "Ruler": "Moon", "Weight": 1.0, "Trend": "Bullish"}, {"Name": "Chitra", "Start": 173.3333, "End": 186.6667, "Ruler": "Mars", "Weight": 1.1, "Trend": "Bullish"}, {"Name": "Swati", "Start": 186.6667, "End": 200.0, "Ruler": "Rahu", "Weight": 0.4, "Trend": "Slightly Bearish"}, {"Name": "Vishakha", "Start": 200.0, "End": 213.3333, "Ruler": "Jupiter", "Weight": 0.3, "Trend": "Mild Bullish"}, {"Name": "Anuradha", "Start": 213.3333, "End": 226.6667, "Ruler": "Saturn", "Weight": 2.0, "Trend": "Strong Bullish"}, {"Name": "Jyeshtha", "Start": 226.6667, "End": 240.0, "Ruler": "Mercury", "Weight": 1.3, "Trend": "Bearish"}, {"Name": "Mula", "Start": 240.0, "End": 253.3333, "Ruler": "Ketu", "Weight": 1.7, "Trend": "Strong Bearish"}, {"Name": "Purva Ashadha", "Start": 253.3333, "End": 266.6667, "Ruler": "Venus", "Weight": 1.0, "Trend": "Bullish"}, {"Name": "Uttara Ashadha", "Start": 266.6667, "End": 280.0, "Ruler": "Sun", "Weight": 1.7, "Trend": "Bullish"}, {"Name": "Shravana", "Start": 280.0, "End": 293.3333, "Ruler": "Moon", "Weight": 3.3, "Trend": "Strong Bullish"}, {"Name": "Dhanishtha", "Start": 293.3333, "End": 306.6667, "Ruler": "Mars", "Weight": 1.1, "Trend": "Bullish"}, {"Name": "Shatabhisha", "Start": 306.6667, "End": 320.0, "Ruler": "Rahu", "Weight": 1.5, "Trend": "Bearish"}, {"Name": "Purva Bhadrapada", "Start": 320.0, "End": 333.3333, "Ruler": "Jupiter", "Weight": 0.5, "Trend": "Mild Bullish"}, {"Name": "Uttara Bhadrapada", "Start": 333.3333, "End": 346.6667, "Ruler": "Saturn", "Weight": 0.9, "Trend": "Mild Bullish"}, {"Name": "Revati", "Start": 346.6667, "End": 360.0, "Ruler": "Mercury", "Weight": 1.3, "Trend": "Bullish"}
]
STANDARD_NAKSHATRA_SPAN = 360.0 / 27.0
STANDARD_PADA_SPAN = STANDARD_NAKSHATRA_SPAN / 4.0

def calculate_nakshatra_from_boundaries(absolute_longitude):
    if not NAKSHATRA_BOUNDARIES: return {"name": "Data Missing", "pada": "N/A", "ruler": "N/A"}
    if absolute_longitude is None or not isinstance(absolute_longitude, (int, float)): return {"name": "Invalid Lon", "pada": "N/A", "ruler": "N/A"}
    epsilon = 1e-9; longitude_norm = (absolute_longitude + epsilon) % 360.0
    for nak_info in NAKSHATRA_BOUNDARIES:
        nak_start = nak_info["Start"]; nak_end = nak_info["End"]
        if nak_start > nak_end: # Handles wrap-around
            if longitude_norm >= nak_start or longitude_norm < nak_end:
                 degrees_into_nakshatra = (longitude_norm - nak_start + 360) % 360; pada_calc = (degrees_into_nakshatra + epsilon) / STANDARD_PADA_SPAN; pada = int(math.floor(pada_calc)) + 1; pada = max(1, min(4, pada)); return {"name": nak_info["Name"], "pada": pada, "ruler": nak_info["Ruler"]}
        elif nak_start <= longitude_norm < nak_end:
            degrees_into_nakshatra = longitude_norm - nak_start; pada_calc = (degrees_into_nakshatra + epsilon) / STANDARD_PADA_SPAN; pada = int(math.floor(pada_calc)) + 1; pada = max(1, min(4, pada)); return {"name": nak_info["Name"], "pada": pada, "ruler": nak_info["Ruler"]}
    return {"name": "Not Found", "pada": "N/A", "ruler": "N/A"}

def print_nakshatras(subject: AstrologicalSubject, chart_type: str):
    if not subject: print(f"Cannot print Nakshatras for {chart_type}, subject is None."); return
    print(f"\n--- {chart_type} Nakshatra Positions (Method: User Boundaries / User Pada Logic) ---")
    points_of_interest_nak = [
        ("Ascendant", "ascendant"), ("MC", "mc"), ("Sun", "sun"), ("Moon", "moon"),
        ("Mercury", "mercury"), ("Venus", "venus"), ("Mars", "mars"), ("Jupiter", "jupiter"),
        ("Saturn", "saturn"), ("Uranus", "uranus"), ("Neptune", "neptune"), ("Pluto", "pluto"),
        ("True Node", "true_node"), ("True S. Node", "true_south_node"),
    ]
    for point_name, attr_name in points_of_interest_nak:
        nak_name, nak_pada, nak_lord = "N/A", "N/A", "N/A"; sign, pos_in_sign_str, retrograde = "N/A", "N/A", ""; output_str = f"{point_name:<12}: Point data unavailable."
        try:
            point_obj = getattr(subject, attr_name, None)
            absolute_longitude = None
            if point_obj and hasattr(point_obj, 'sign_pos'):
                absolute_longitude = point_obj.sign_pos
            elif point_obj and hasattr(point_obj, 'position') and hasattr(point_obj, 'sign'):
                sign_start_lon = SIGN_START_LONGITUDES.get(point_obj.sign)
                if sign_start_lon is not None:
                    absolute_longitude = (sign_start_lon + point_obj.position) % 360

            sign = getattr(point_obj, 'sign', 'N/A')
            pos_in_sign = getattr(point_obj, 'position', None)
            pos_in_sign_str = f"{pos_in_sign:.2f}" if pos_in_sign is not None else "N/A"
            retrograde = " (R)" if hasattr(point_obj, 'retrograde') and getattr(point_obj, 'retrograde', False) else "" # Check attr exists AND is True

            if absolute_longitude is not None:
                nak_info = calculate_nakshatra_from_boundaries(absolute_longitude)
                nak_name = nak_info.get('name', 'Calc Error')
                nak_pada = nak_info.get('pada', 'N/A')
                nak_lord = nak_info.get('ruler', 'N/A')
                output_str = f"{point_name:<12}: {nak_name:<15} (Pada {nak_pada}, Lord: {nak_lord:<8}) [{sign} {pos_in_sign_str}°{retrograde}]"
            elif point_obj:
                output_str = f"{point_name:<12}: Position/Sign data insufficient [{sign} {pos_in_sign_str}°{retrograde}]"
            # else: output_str remains "Point data unavailable."

        except Exception as e: print(f"Error processing Nakshatra for {point_name} ({attr_name}): {e}"); output_str=f"{point_name:<12}: Error processing Nakshatra."
        print(output_str)
    print("-" * 75)


# --- CUSTOM SPEED CALCULATION FUNCTION ---
def calculate_custom_speeds(subject_t0: AstrologicalSubject):
    if not subject_t0: print("ERROR (calculate_custom_speeds): Input subject_t0 is None."); return None
    try:
        planets_t0 = {};
        for attr_name in EXPECTED_BODIES_FOR_SPEED:
            if hasattr(subject_t0, attr_name):
                planet_obj = getattr(subject_t0, attr_name); dict_key = PLANET_ATTRIBUTE_MAP.get(attr_name, attr_name)
                if not dict_key: continue
                if planet_obj and hasattr(planet_obj, 'sign_pos'): planets_t0[dict_key] = {'lon': planet_obj.sign_pos}
                elif planet_obj and hasattr(planet_obj, 'position') and hasattr(planet_obj, 'sign'):
                    sign_start = SIGN_START_LONGITUDES.get(planet_obj.sign)
                    if sign_start is not None: planets_t0[dict_key] = {'lon': (sign_start + planet_obj.position) % 360.0}
        if not planets_t0: print("ERROR (calculate_custom_speeds): Failed to retrieve any valid planet longitude for t0."); return None
        if not all(hasattr(subject_t0, attr) for attr in ['year', 'month', 'day', 'hour', 'minute']): print("ERROR (calculate_custom_speeds): subject_t0 missing time attributes."); return None
        if not all(isinstance(getattr(subject_t0, attr), int) for attr in ['year', 'month', 'day', 'hour', 'minute']): print("ERROR (calculate_custom_speeds): subject_t0 has invalid time attributes."); return None
        try: t0_dt_utc = datetime(subject_t0.year, subject_t0.month, subject_t0.day, subject_t0.hour, subject_t0.minute, 0, tzinfo=timezone.utc)
        except ValueError as ve: print(f"ERROR (calculate_custom_speeds): Invalid date/time values in subject_t0: {ve}"); return None
        t1_dt_utc = t0_dt_utc + timedelta(days=1)
        subject_t1 = AstrologicalSubject( subject_t0.name + " +1d", t1_dt_utc.year, t1_dt_utc.month, t1_dt_utc.day, t1_dt_utc.hour, t1_dt_utc.minute, city=getattr(subject_t0, 'city', None), nation=getattr(subject_t0, 'nation', None), lng=getattr(subject_t0, 'lng', None), lat=getattr(subject_t0, 'lat', None), tz_str=getattr(subject_t0, 'tz_str', None), zodiac_type=getattr(subject_t0, 'zodiac_type', 'Tropical'), sidereal_mode=getattr(subject_t0, 'sidereal_mode', 'LAHIRI'), houses_system_identifier=getattr(subject_t0, 'houses_system_identifier', 'P'), online=KERYKEION_ONLINE_MODE )
        planets_t1 = {};
        for attr_name in EXPECTED_BODIES_FOR_SPEED:
             if hasattr(subject_t1, attr_name):
                  planet_obj = getattr(subject_t1, attr_name); dict_key = PLANET_ATTRIBUTE_MAP.get(attr_name, attr_name)
                  if not dict_key: continue
                  if planet_obj and hasattr(planet_obj, 'sign_pos'): planets_t1[dict_key] = {'lon': planet_obj.sign_pos}
                  elif planet_obj and hasattr(planet_obj, 'position') and hasattr(planet_obj, 'sign'):
                       sign_start = SIGN_START_LONGITUDES.get(planet_obj.sign)
                       if sign_start is not None: planets_t1[dict_key] = {'lon': (sign_start + planet_obj.position) % 360.0}
        if not planets_t1: print("ERROR (calculate_custom_speeds): Failed to retrieve any valid planet longitude for t1."); del subject_t1; return None
        calculated_speeds = {};
        for planet_key, p0_data in planets_t0.items():
            p1_data = planets_t1.get(planet_key)
            if not p1_data: continue
            lon0 = p0_data['lon']; lon1 = p1_data['lon']
            delta_lon = lon1 - lon0
            if delta_lon > 180: delta_lon -= 360.0
            elif delta_lon < -180: delta_lon += 360.0
            calculated_speeds[planet_key] = delta_lon
        del subject_t1
        if not calculated_speeds: print("\nERROR (calculate_custom_speeds): No speeds were calculated."); return None
        return calculated_speeds
    except Exception as e: print(f"ERROR during custom speed calculation: {e}"); traceback.print_exc(); return None

# --- HELPER FUNCTION FOR SPEED CLASSIFICATION ---
def get_speed_classification(planet_name, speed):
    if speed is None: return "N/A"
    abs_speed = abs(speed); is_retro = speed < 0
    if abs_speed < STATIONARY_SPEED_THRESHOLD * 10: return "Stationary"
    rx_tag = " Rx" if is_retro else ""
    if planet_name == "Moon":
        if abs_speed > 14.5: return "Very Fast";
        if abs_speed > 13.5: return "Fast"
        if abs_speed > 12.0: return "Normal"
        if abs_speed > 11.0: return "Slow"
        return "Very Slow"
    elif planet_name == "Mercury":
        if abs_speed > 1.9: return "Very Fast" + rx_tag
        if abs_speed > 1.5: return "Fast" + rx_tag
        if abs_speed > 0.6: return "Normal" + rx_tag
        if abs_speed > 0.1: return "Slow" + rx_tag
        return "Very Slow" + rx_tag
    elif planet_name == "Venus":
        if abs_speed > 1.22: return "Very Fast" + rx_tag
        if abs_speed > 1.18: return "Fast" + rx_tag
        if abs_speed > 0.8: return "Normal" + rx_tag
        if abs_speed > 0.1: return "Slow" + rx_tag
        return "Very Slow" + rx_tag
    elif planet_name == "Sun": return "Normal"
    elif planet_name == "Mars":
        if abs_speed > 0.7: return "Very Fast" + rx_tag
        if abs_speed > 0.6: return "Fast" + rx_tag
        if abs_speed > 0.4: return "Normal" + rx_tag
        if abs_speed > 0.15: return "Slow" + rx_tag
        return "Very Slow" + rx_tag
    elif planet_name == "Jupiter":
        if abs_speed > 0.15: return "Fast" + rx_tag
        if abs_speed > 0.05: return "Normal" + rx_tag
        if abs_speed > 0.02: return "Slow" + rx_tag
        return "Very Slow" + rx_tag
    elif planet_name == "Saturn":
        if abs_speed > 0.07: return "Fast" + rx_tag
        if abs_speed > 0.02: return "Normal" + rx_tag
        if abs_speed > 0.01: return "Slow" + rx_tag
        return "Very Slow" + rx_tag
    elif planet_name == "Uranus":
        if abs_speed > 0.03: return "Normal" + rx_tag
        if abs_speed > 0.01: return "Slow" + rx_tag
        return "Very Slow" + rx_tag
    elif planet_name == "Neptune":
        if abs_speed > 0.02: return "Normal" + rx_tag
        if abs_speed > 0.005: return "Slow" + rx_tag
        return "Very Slow" + rx_tag
    elif planet_name == "Pluto":
        if abs_speed > 0.01: return "Normal" + rx_tag
        if abs_speed > 0.002: return "Slow" + rx_tag
        return "Very Slow" + rx_tag
    elif planet_name == "True Node" or planet_name == "True S. Node":
        # Node speed is usually negative (retrograde) ~ -0.05 deg/day
        if speed > STATIONARY_SPEED_THRESHOLD * 10: return "Slow Direct" # Very rare
        if abs_speed > 0.055: return "Fast Rx"
        if abs_speed > 0.045: return "Normal Rx"
        if abs_speed > STATIONARY_SPEED_THRESHOLD * 10 : return "Slow Rx"
        return "Stationary" # If very close to zero speed
    else: return "N/A"

# --- FUNCTION TO PRINT PLANETARY SPEEDS with Classification ---
def print_planetary_speeds(speeds_dict: dict, transit_subject: AstrologicalSubject):
    if not speeds_dict:
        print("\nNo speeds data available to print.")
        return
    if not transit_subject:
        print("\nWarning: Transit subject needed for Rx status in speed table.")
    print("\n" + "="*30); print("      TRANSIT PLANETARY SPEEDS"); print("="*30)
    print(f"{'Planet':<12} {'Speed (°/day)':<15} {'Status':<8} {'Classification':<15}")
    print("-" * 55)
    for planet_key in PLANETS_FOR_SPEED_TABLE:
        speed = speeds_dict.get(planet_key)
        speed_str = f"{speed:+.4f}" if speed is not None else "N/A"
        rx_status = ""
        classification = "N/A"

        # Determine Rx status from the transit subject object if available
        if transit_subject:
            attr_name = next((attr for attr, key in PLANET_ATTRIBUTE_MAP.items() if key == planet_key), None)
            if attr_name:
                try:
                    planet_obj = getattr(transit_subject, attr_name, None)
                    if planet_obj and hasattr(planet_obj, 'retrograde') and getattr(planet_obj, 'retrograde', False):
                        # Special case: Nodes are almost always Rx, so only show Rx if the object explicitly says so (handles rare direct periods)
                        # For other planets, if retrograde is True, show Rx.
                        if "Node" not in planet_key:
                           rx_status = "Rx"
                        elif getattr(planet_obj, 'retrograde', False): # Explicitly check if Node object is marked Rx
                            rx_status = "Rx"

                except Exception as e:
                    pass # Ignore errors getting Rx status

        # Get classification based on calculated speed
        classification = get_speed_classification(planet_key, speed)

        # If classification already includes Rx (from get_speed_classification), don't duplicate in Status column
        if " Rx" in classification:
            rx_status = "" # Classification handles it
        elif classification == "Slow Direct" and "Node" in planet_key:
             rx_status = "" # Classification handles it


        print(f"{planet_key:<12} {speed_str:<15} {rx_status:<8} {classification:<15}")
    print("-" * 55)


# --- ASPECT CALCULATION FUNCTION ---
def print_manual_transit_aspects( natal_subject: AstrologicalSubject, transit_subject: AstrologicalSubject, transit_utc_dt: datetime, aspects_list: list, max_orb: float, planets_for_aspects: list, local_tz_str: str ):
    if not natal_subject or not transit_subject: print("\nCannot calculate transit aspects: Natal or Transit subject missing."); return
    if not transit_utc_dt: print("\nCannot calculate aspect timing: Transit UTC datetime missing."); return
    local_timezone = None
    if _use_zoneinfo:
        try: local_timezone = ZoneInfo(local_tz_str)
        except Exception as e: print(f"Warning: Could not get local ZoneInfo for '{local_tz_str}': {e}")
    elif _use_pytz:
        try: local_timezone = pytz.timezone(local_tz_str)
        except Exception as e: print(f"Warning: Could not get local pytz timezone for '{local_tz_str}': {e}")
    if not local_timezone: print("Warning: Could not determine local timezone. Exact times will be shown in UTC.")
    print("\n" + "="*30); print(f"   TRANSIT ASPECTS TO NATAL (Using Custom Speed Calc + Timing)"); print(f"   (Max Orb: {max_orb:.1f}°, Aspects: {aspects_list})"); print("="*30)
    calculated_transit_speeds = calculate_custom_speeds(transit_subject)
    if not calculated_transit_speeds: print("ERROR: Failed to calculate custom transit speeds. Aborting aspect calculation."); return
    # Print speeds table right before aspects
    print_planetary_speeds(calculated_transit_speeds, transit_subject)

    natal_planets = {}; transit_planets = {}; aspects_found = []
    # Get Natal Planet Positions
    for planet_key in planets_for_aspects:
        attr_name = next((attr for attr, key in PLANET_ATTRIBUTE_MAP.items() if key == planet_key), None);
        if not attr_name: continue
        try:
            n_planet = getattr(natal_subject, attr_name, None); abs_lon = None
            if n_planet and hasattr(n_planet, 'sign_pos'): abs_lon = n_planet.sign_pos
            elif n_planet and hasattr(n_planet, 'sign') and hasattr(n_planet, 'position'):
                sign_start_lon = SIGN_START_LONGITUDES.get(n_planet.sign);
                if sign_start_lon is not None: abs_lon = (sign_start_lon + n_planet.position) % 360
            if abs_lon is not None: natal_planets[planet_key] = abs_lon
        except Exception as e: print(f"  - Error getting natal {planet_key}: {e}")

    # Get Transit Planet Positions and Speeds
    for planet_key in planets_for_aspects:
        attr_name = next((attr for attr, key in PLANET_ATTRIBUTE_MAP.items() if key == planet_key), None);
        if not attr_name: continue
        try:
            t_planet = getattr(transit_subject, attr_name, None); abs_lon = None
            if t_planet and hasattr(t_planet, 'sign_pos'): abs_lon = t_planet.sign_pos
            elif t_planet and hasattr(t_planet, 'sign') and hasattr(t_planet, 'position'):
                sign_start_lon = SIGN_START_LONGITUDES.get(t_planet.sign);
                if sign_start_lon is not None: abs_lon = (sign_start_lon + t_planet.position) % 360

            custom_speed = calculated_transit_speeds.get(planet_key)
            # Store position and speed if both are valid
            if abs_lon is not None and custom_speed is not None:
                 transit_planets[planet_key] = {'lon': abs_lon, 'speed': custom_speed}
            elif abs_lon is not None and planet_key == 'Ascendant': # Handle Ascendant speed (assume ~1 deg/4min = 15 deg/hr = 360 deg/day)
                 # Crude approximation - only use for orb calc, not timing
                 transit_planets[planet_key] = {'lon': abs_lon, 'speed': 360.0} # Rough speed
            elif abs_lon is not None:
                 print(f"  - Warning: Missing speed for transit {planet_key}. Using position only for orb check.")
                 # Store with None speed? Or skip? Let's store with None, aspect calc needs to handle it.
                 transit_planets[planet_key] = {'lon': abs_lon, 'speed': None}

        except Exception as e: print(f"  - Error getting transit {planet_key}: {e}")

    if not natal_planets or not transit_planets: print("Error: Insufficient planet data (natal or transit) to calculate aspects."); return

    # Calculate Aspects
    for tp_name, tp_data in transit_planets.items():
        # Skip if transit planet data is incomplete for calculation
        if 'lon' not in tp_data: continue
        tp_lon = tp_data['lon']
        # Speed might be None (e.g., for Ascendant if not calculated, or if calculation failed)
        tp_speed = tp_data.get('speed') # Use .get() for safety

        for np_name, np_lon in natal_planets.items():
            raw_diff = tp_lon - np_lon
            for aspect_angle in aspects_list:
                delta = (raw_diff - aspect_angle + 180 + 3600) % 360 - 180; orb = abs(delta)
                if orb <= max_orb:
                    aspect_name = ASPECT_NAMES.get(aspect_angle, f"{aspect_angle}°"); status = "N/A"; exact_time_str = "N/A"

                    # Determine Status (Applying/Separating) if speed is available and non-zero
                    if tp_speed is not None and abs(tp_speed) > STATIONARY_SPEED_THRESHOLD:
                        # Standard Planets (Direct movement): Applying if approaching exact aspect (delta <= 0)
                        # Retrograde Planets (Negative speed): Applying if moving towards exact aspect (delta >= 0)
                        # Nodes (Usually Rx, Negative speed): Applying if moving towards exact aspect (delta >= 0)
                        is_applying = False
                        if tp_name == "True Node" or tp_name == "True S. Node":
                            is_applying = (delta >= 0) # Rx motion standard for nodes
                        elif tp_speed > 0: # Direct motion
                            is_applying = (delta <= 0)
                        else: # Retrograde motion (negative speed)
                            is_applying = (delta >= 0)
                        status = "Applying" if is_applying else "Separating"

                    elif tp_speed is not None and abs(tp_speed) <= STATIONARY_SPEED_THRESHOLD:
                         status = "Stationary"
                         # If stationary right on the aspect, show 'Peak Now'
                         if abs(delta) < 0.1: # Small threshold for 'exact' stationary
                             exact_time_str = "Peak Now"

                    # Calculate Estimated Exact Time if speed is available and non-zero
                    # Skip timing for Ascendant as speed is approximate or unavailable
                    if tp_speed is not None and abs(tp_speed) > 1e-9 and tp_name != 'Ascendant' and status != "Stationary": # Need significant speed for calculation
                        time_diff_days = -delta / tp_speed; exact_time_utc = transit_utc_dt + timedelta(days=time_diff_days)
                        if local_timezone:
                            try:
                                exact_time_local = exact_time_utc.astimezone(local_timezone); transit_local_date = transit_utc_dt.astimezone(local_timezone).date()
                                if exact_time_local.date() != transit_local_date: exact_time_str = exact_time_local.strftime('%m/%d %H:%M %Z')
                                else: exact_time_str = exact_time_local.strftime('%H:%M %Z')
                            except Exception as e_tz: exact_time_str = exact_time_utc.strftime('%m/%d %H:%M UTC') # Fallback to UTC on error
                        else: # No local timezone available
                            if exact_time_utc.date() != transit_utc_dt.date(): exact_time_str = exact_time_utc.strftime('%m/%d %H:%M UTC')
                            else: exact_time_str = exact_time_utc.strftime('%H:%M UTC')
                    elif tp_name == 'Ascendant':
                        exact_time_str = "N/A (Asc)" # Indicate Ascendant timing is not calculated

                    aspects_found.append({ 'tp_name': tp_name, 'aspect_name': aspect_name, 'np_name': np_name, 'orb': orb, 'status': status, 'exact_time': exact_time_str })

    if not aspects_found: print("\nNo significant aspects found within the specified orb using custom speeds."); return
    aspects_found.sort(key=lambda x: x['orb']) # Sort by orb tightness
    print(f"\n{'Transit Planet':<15} {'Aspect':<10} {'Natal Planet':<15} {'Orb':<7} {'Status':<10} {'Est. Exact':<15}")
    print("-" * 75)
    for aspect in aspects_found: orb_str = f"{aspect['orb']:.2f}°"; print(f"{aspect['tp_name']:<15} {aspect['aspect_name']:<10} {aspect['np_name']:<15} {orb_str:<7} {aspect['status']:<10} {aspect['exact_time']:<15}")
    print("-" * 75)


# --- NEW FUNCTION TO DERIVE HOUSE LORDS ---
def print_derived_house_lords(subject: AstrologicalSubject, chart_type: str):
    """
    Calculates and prints the House Lords based on the cusp sign of each house
    using the ZODIAC_RULERS dictionary.
    """
    if not subject:
        print(f"Warning: Cannot derive {chart_type} House Lords. Subject object is missing.")
        return

    print(f"\n--- {chart_type} House Lords ---")

    # Map house numbers to the attribute names on the AstrologicalSubject object
    house_attr_map = {
        1: 'first_house', 2: 'second_house', 3: 'third_house',
        4: 'fourth_house', 5: 'fifth_house', 6: 'sixth_house',
        7: 'seventh_house', 8: 'eighth_house', 9: 'ninth_house',
        10: 'tenth_house', 11: 'eleventh_house', 12: 'twelfth_house'
    }
    # Map house numbers to display names (optional, can just use number)
    house_display_map = {
        1: 'First', 2: 'Second', 3: 'Third', 4: 'Fourth', 5: 'Fifth', 6: 'Sixth',
        7: 'Seventh', 8: 'Eighth', 9: 'Ninth', 10: 'Tenth', 11: 'Eleventh', 12: 'Twelfth'
    }

    print(f"{'House':<12} {'Cusp Sign':<10} {'House Lord':<10}")
    print("-" * 34)

    all_houses_found = True
    for i in range(1, 13):
        house_attr_name = house_attr_map.get(i)
        house_display_name = house_display_map.get(i, str(i)) # Fallback to number if name missing

        if not house_attr_name:
            print(f"{house_display_name:<12} {'N/A':<10} {'Attribute Error':<10}")
            all_houses_found = False
            continue

        try:
            house_obj = getattr(subject, house_attr_name, None)
            if house_obj and hasattr(house_obj, 'sign'):
                cusp_sign = house_obj.sign # e.g., "Gem", "Can"
                house_lord = ZODIAC_RULERS.get(cusp_sign, "Unknown Ruler") # Use .get() for safety
                print(f"{house_display_name:<12} {cusp_sign:<10} {house_lord:<10}")
            else:
                # This might happen if house system calculation failed or attribute is missing
                print(f"{house_display_name:<12} {'N/A':<10} {'Sign N/A':<10}")
                all_houses_found = False
        except Exception as e:
            print(f"Error getting lord for {house_display_name} House: {e}")
            print(f"{house_display_name:<12} {'Error':<10} {'Processing Error':<10}")
            all_houses_found = False

    if not all_houses_found:
         print("Warning: Could not determine lords for all houses.")
    print("-" * 34)


# --- MAIN EXECUTION ---
if __name__ == "__main__":
    print("Calculating UTC times...")
    natal_utc_dt = get_utc_datetime( natal_year, natal_month, natal_day, natal_hour_local, natal_minute_local, location_timezone_str)
    transit_utc_dt = get_utc_datetime( transit_year, transit_month, transit_day, transit_hour_local, transit_minute_local, location_timezone_str)
    if not natal_utc_dt or not transit_utc_dt:
         print("Error: Could not calculate required UTC times. Exiting.")
         exit(1)

    print("\nCreating AstrologicalSubject instances...")
    natal_subject = None; transit_subject = None
    try:
        # Create Natal Subject
        natal_subject = AstrologicalSubject(
            name=natal_name,
            year=natal_utc_dt.year, month=natal_utc_dt.month, day=natal_utc_dt.day,
            hour=natal_utc_dt.hour, minute=natal_utc_dt.minute,
            city=location_city, nation=location_nation,
            lat=location_latitude, lng=location_longitude,
            tz_str=location_timezone_str,
            zodiac_type=zodiac_type,
            sidereal_mode=ayanamsa,
            houses_system_identifier=house_system_identifier, # Using Sripathi 'S'
            online=KERYKEION_ONLINE_MODE
        )
        print(f"- Successfully created: {natal_subject.name}")

    except Exception as e: print(f"Error creating Natal AstrologicalSubject: {e}"); traceback.print_exc()

    try:
         # Create Transit Subject
        transit_subject = AstrologicalSubject(
            name=transit_name,
            year=transit_utc_dt.year, month=transit_utc_dt.month, day=transit_utc_dt.day,
            hour=transit_utc_dt.hour, minute=transit_utc_dt.minute,
            city=location_city, nation=location_nation,
            lat=location_latitude, lng=location_longitude,
            tz_str=location_timezone_str,
            zodiac_type=zodiac_type,
            sidereal_mode=ayanamsa,
            houses_system_identifier=house_system_identifier, # Using Sripathi 'S'
            online=KERYKEION_ONLINE_MODE
        )
        print(f"- Successfully created: {transit_subject.name}")

    except Exception as e: print(f"Error creating Transit AstrologicalSubject: {e}"); traceback.print_exc()

    # --- Print Natal Chart Details using Standard Report ---
    if natal_subject:
        print("\n" + "="*30); print(f"   STANDARD NATAL CHART REPORT: {natal_name}"); print(f"   (Using {house_system_name} Houses, {ayanamsa} Ayanamsa)"); print("="*30)
        try:
            natal_report_obj = Report(natal_subject)
            natal_report_obj.print_report() # This includes standard house cusps table
            print("-" * 70) # Add separator
        except Exception as e:
            print(f"\nError generating standard Natal Report: {e}")
            traceback.print_exc()
        # Print Nakshatras
        try: print_nakshatras(natal_subject, "Natal")
        except Exception as e: print(f"\nError printing Natal Nakshatras: {e}")
    else: print("\nSkipping Natal Report (Subject creation failed).")

    # --- Print Transit Chart Details using Standard Report ---
    if transit_subject:
        print("\n" + "="*30); print(f"   STANDARD TRANSIT CHART REPORT: {transit_name}"); print(f"   (Using {house_system_name} Houses, {ayanamsa} Ayanamsa)"); print("="*30)
        try:
            transit_report_obj = Report(transit_subject)
            transit_report_obj.print_report() # This includes standard house cusps table
            print("-" * 70) # Add separator
        except Exception as e:
            print(f"\nError generating standard Transit Report: {e}")
            traceback.print_exc()
        # Print Nakshatras
        try: print_nakshatras(transit_subject, "Transit")
        except Exception as e: print(f"\nError printing Transit Nakshatras: {e}")
    else: print("\nSkipping Transit Report (Subject creation failed).")

    # --- Print Derived House Lords ---
    print("\n" + "="*30)
    print("   DERIVED HOUSE LORDS")
    print("(Based on Standard Report Cusps)")
    print("="*30)
    if natal_subject:
        try:
            print_derived_house_lords(natal_subject, "Natal")
        except Exception as e:
            print(f"\nError printing Derived Natal House Lords: {e}")
            traceback.print_exc()
    else:
        print("\n--- Natal House Lords ---")
        print("Skipped (Natal Subject creation failed).")
        print("-" * 34)

    if transit_subject:
        try:
            print_derived_house_lords(transit_subject, "Transit")
        except Exception as e:
            print(f"\nError printing Derived Transit House Lords: {e}")
            traceback.print_exc()
    else:
        print("\n--- Transit House Lords ---")
        print("Skipped (Transit Subject creation failed).")
        print("-" * 34)
    print("="*30)


    # --- Calculate and Print Transit Aspects ---
    if natal_subject and transit_subject and transit_utc_dt:
        try:
            print_manual_transit_aspects(
                natal_subject,
                transit_subject,
                transit_utc_dt,
                ASPECTS_TO_CHECK,
                MAX_ASPECT_ORB,
                PLANETS_FOR_ASPECTS,
                location_timezone_str
            )
        except Exception as e: print(f"\nError calculating/printing Transit Aspects: {e}"); traceback.print_exc()
    else: print("\nSkipping Transit Aspect calculation (Natal/Transit subject or UTC time missing).")


    print("\nScript finished.")
