# -*- coding: utf-8 -*-
from kerykeion import AstrologicalSubject, Report
from datetime import datetime, timezone, timedelta
import math
import pprint # Added from speed script
import inspect # Added from speed script

# --- Configuration (Combined) ---
location_city = "New York"; location_nation = "US"; location_latitude = 40.7128; location_longitude = -74.0060; location_timezone_str = "America/New_York"
natal_name = "Natal Chart (Mar 4, 1957)"; natal_year = 1957; natal_month = 3; natal_day = 4; natal_hour_local = 8; natal_minute_local = 30
transit_name = "Transit Chart (Mar 31, 2025)"; transit_year = 2025; transit_month = 3; transit_day = 28; transit_hour_local = 8; transit_minute_local = 30
ayanamsa = "LAHIRI"; house_system_identifier = "S"; zodiac_type = "Sidereal"
house_system_names = { "P": "Placidus", "K": "Koch", "R": "Regiomontanus", "C": "Campanus", "E": "Equal", "W": "Whole Sign", "X": "Axial Rotation System", "H": "Horizontal System", "T": "Polich/Page (Topocentric)", "B": "Alcabitus", "M": "Morinus", "U": "Krusinski-Pisa-Goelzer", "S": "Sripathi" }
house_system_name = house_system_names.get(house_system_identifier, f"Unknown ({house_system_identifier})")
KERYKEION_ONLINE_MODE = False # Set to True if you don't have Swiss Ephemeris locally

# --- Aspect Configuration ---
ASPECTS_TO_CHECK = [0, 60, 90, 120, 180] # Conjunction, Sextile, Square, Trine, Opposition
ASPECT_NAMES = { 0: "Conjunct", 60: "Sextile", 90: "Square", 120: "Trine", 180: "Opposite"}
MAX_ASPECT_ORB = 5.0 # Degrees

# --- Planet/Point Configuration (Consistent) ---
# List of planets/points to *attempt* to include in calculations
# MC might fail with Sripathi, others might lack speed depending on Kerykeion version/calc method
PLANETS_FOR_ASPECTS = [
    "Sun", "Moon", "Mercury", "Venus", "Mars", "Jupiter",
    "Saturn", "Uranus", "Neptune", "Pluto", "Ascendant",
    "True Node" # Assuming True Node speed is desired/calculated
    # Add "Chiron", "Mean Lilith" etc. if desired and calculated by speed script
]
# List of bodies expected by the custom speed calculation function
EXPECTED_BODIES_FOR_SPEED = [
    'sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn',
    'uranus', 'neptune', 'pluto', 'mean_node', 'true_node',
    # 'chiron', 'mean_lilith' # Include if you want their speeds calculated
]
# Consistent mapping from Kerykeion attribute name to display/dictionary key name
PLANET_ATTRIBUTE_MAP = {
    'sun': 'Sun', 'moon': 'Moon', 'mercury': 'Mercury', 'venus': 'Venus',
    'mars': 'Mars', 'jupiter': 'Jupiter', 'saturn': 'Saturn', 'uranus': 'Uranus',
    'neptune': 'Neptune', 'pluto': 'Pluto', 'mean_node': 'Mean_Node',
    'true_node': 'True_Node', 'chiron': 'Chiron', 'mean_lilith': 'Mean_Lilith',
    'ascendant': 'Ascendant', 'mc': 'MC', # Keep MC/ASC here for potential Nakshatra use
    'true_south_node': 'True S. Node'
}

SIGN_START_LONGITUDES = { "Ari": 0.0, "Tau": 30.0, "Gem": 60.0, "Can": 90.0, "Leo": 120.0, "Vir": 150.0, "Lib": 180.0, "Sco": 210.0, "Sag": 240.0, "Cap": 270.0, "Aqu": 300.0, "Pis": 330.0 }

# --- Timezone Helper Function ---
# [Keep the get_utc_datetime function as it was]
def get_utc_datetime(year, month, day, hour, minute, tz_str):
    try:
        from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
        try:
            local_tz = ZoneInfo(tz_str); local_dt = datetime(year, month, day, hour, minute, tzinfo=local_tz); utc_dt = local_dt.astimezone(timezone.utc)
            print(f"Info: Using zoneinfo for {year}-{month}-{day}. Local: {local_dt.strftime('%Y-%m-%d %H:%M %Z%z')}, UTC: {utc_dt.strftime('%Y-%m-%d %H:%M %Z')}")
            return utc_dt
        except ZoneInfoNotFoundError: print(f"Error: Timezone '{tz_str}' not found by zoneinfo."); return None
        except Exception as e_zi: print(f"Error: zoneinfo error for {year}-{month}-{day}: {e_zi}"); return None
    except ImportError:
        print("Warning: zoneinfo module not available (Python 3.9+). Trying pytz.")
        try:
            import pytz
            try:
                local_tz = pytz.timezone(tz_str); local_dt = datetime(year, month, day, hour, minute); local_dt_aware = local_tz.localize(local_dt); utc_dt = local_dt_aware.astimezone(pytz.utc)
                print(f"Info: Using pytz fallback for {year}-{month}-{day}. Local: {local_dt_aware.strftime('%Y-%m-%d %H:%M %Z%z')}, UTC: {utc_dt.strftime('%Y-%m-%d %H:%M %Z')}")
                return utc_dt
            except pytz.exceptions.UnknownTimeZoneError: print(f"Error: Timezone '{tz_str}' not found by pytz."); return None
            except Exception as e_pytz: print(f"Error: pytz error for {year}-{month}-{day}: {e_pytz}"); return None
        except ImportError: print("Error: Neither zoneinfo nor pytz is available."); return None

# --- NAKSHATRA DATA AND FUNCTIONS ---
# [Keep NAKSHATRA_BOUNDARIES, STANDARD_NAKSHATRA_SPAN, STANDARD_PADA_SPAN]
# [Keep calculate_nakshatra_from_boundaries function]
# [Keep print_nakshatras function - maybe adjust points_of_interest if needed]
NAKSHATRA_BOUNDARIES = [
    {"Name": "Ashwini", "Start": 0.0, "End": 13.3333, "Ruler": "Ketu", "Weight": 1.3, "Trend": "Bullish"},
    {"Name": "Bharani", "Start": 13.3333, "End": 26.6667, "Ruler": "Venus", "Weight": 0.9, "Trend": "Bullish"},
    {"Name": "Krittika", "Start": 26.6667, "End": 40.0, "Ruler": "Sun", "Weight": 0.7, "Trend": "Bullish"},
    {"Name": "Rohini", "Start": 40.0, "End": 53.3333, "Ruler": "Moon", "Weight": 3.5, "Trend": "Strong Bullish"},
    {"Name": "Mrigashira", "Start": 53.3333, "End": 66.6667, "Ruler": "Mars", "Weight": 1.0, "Trend": "Bullish"},
    {"Name": "Ardra", "Start": 66.6667, "End": 80.0, "Ruler": "Rahu", "Weight": 0.5, "Trend": "Strong Bearish"},
    {"Name": "Punarvasu", "Start": 80.0, "End": 93.3333, "Ruler": "Jupiter", "Weight": 1.1, "Trend": "Bullish"},
    {"Name": "Pushya", "Start": 93.3333, "End": 106.6667, "Ruler": "Saturn", "Weight": 4.0, "Trend": "Strong Bullish"},
    {"Name": "Ashlesha", "Start": 106.6667, "End": 120.0, "Ruler": "Mercury", "Weight": 1.1, "Trend": "Bearish"},
    {"Name": "Magha", "Start": 120.0, "End": 133.3333, "Ruler": "Ketu", "Weight": 0.5, "Trend": "Slightly Bullish"},
    {"Name": "Purva Phalguni", "Start": 133.3333, "End": 146.6667, "Ruler": "Venus", "Weight": 1.2, "Trend": "Bullish"},
    {"Name": "Uttara Phalguni", "Start": 146.6667, "End": 160.0, "Ruler": "Sun", "Weight": 1.1, "Trend": "Bullish"},
    {"Name": "Hasta", "Start": 160.0, "End": 173.3333, "Ruler": "Moon", "Weight": 1.0, "Trend": "Bullish"},
    {"Name": "Chitra", "Start": 173.3333, "End": 186.6667, "Ruler": "Mars", "Weight": 1.1, "Trend": "Bullish"},
    {"Name": "Swati", "Start": 186.6667, "End": 200.0, "Ruler": "Rahu", "Weight": 0.4, "Trend": "Slightly Bearish"},
    {"Name": "Vishakha", "Start": 200.0, "End": 213.3333, "Ruler": "Jupiter", "Weight": 0.3, "Trend": "Mild Bullish"},
    {"Name": "Anuradha", "Start": 213.3333, "End": 226.6667, "Ruler": "Saturn", "Weight": 2.0, "Trend": "Strong Bullish"},
    {"Name": "Jyeshtha", "Start": 226.6667, "End": 240.0, "Ruler": "Mercury", "Weight": 1.3, "Trend": "Bearish"},
    {"Name": "Mula", "Start": 240.0, "End": 253.3333, "Ruler": "Ketu", "Weight": 1.7, "Trend": "Strong Bearish"},
    {"Name": "Purva Ashadha", "Start": 253.3333, "End": 266.6667, "Ruler": "Venus", "Weight": 1.0, "Trend": "Bullish"},
    {"Name": "Uttara Ashadha", "Start": 266.6667, "End": 280.0, "Ruler": "Sun", "Weight": 1.7, "Trend": "Bullish"},
    {"Name": "Shravana", "Start": 280.0, "End": 293.3333, "Ruler": "Moon", "Weight": 3.3, "Trend": "Strong Bullish"},
    {"Name": "Dhanishtha", "Start": 293.3333, "End": 306.6667, "Ruler": "Mars", "Weight": 1.1, "Trend": "Bullish"},
    {"Name": "Shatabhisha", "Start": 306.6667, "End": 320.0, "Ruler": "Rahu", "Weight": 1.5, "Trend": "Bearish"},
    {"Name": "Purva Bhadrapada", "Start": 320.0, "End": 333.3333, "Ruler": "Jupiter", "Weight": 0.5, "Trend": "Mild Bullish"},
    {"Name": "Uttara Bhadrapada", "Start": 333.3333, "End": 346.6667, "Ruler": "Saturn", "Weight": 0.9, "Trend": "Mild Bullish"},
    {"Name": "Revati", "Start": 346.6667, "End": 360.0, "Ruler": "Mercury", "Weight": 1.3, "Trend": "Bullish"}
]
STANDARD_NAKSHATRA_SPAN = 360.0 / 27.0 # 13.333... degrees
STANDARD_PADA_SPAN = STANDARD_NAKSHATRA_SPAN / 4.0 # 3.333... degrees

def calculate_nakshatra_from_boundaries(absolute_longitude):
    if not NAKSHATRA_BOUNDARIES: return {"name": "Data Missing", "pada": "N/A", "ruler": "N/A"}
    if absolute_longitude is None or not isinstance(absolute_longitude, (int, float)): return {"name": "Invalid Lon", "pada": "N/A", "ruler": "N/A"}
    epsilon = 1e-9
    longitude_norm = (absolute_longitude + epsilon) % 360.0
    for nak_info in NAKSHATRA_BOUNDARIES:
        nak_start = nak_info["Start"]; nak_end = nak_info["End"]
        if nak_start <= longitude_norm < nak_end:
            degrees_into_nakshatra = longitude_norm - nak_start
            pada_calc = (degrees_into_nakshatra + epsilon) / STANDARD_PADA_SPAN
            pada = int(math.floor(pada_calc)) + 1; pada = max(1, min(4, pada))
            return {"name": nak_info["Name"], "pada": pada, "ruler": nak_info["Ruler"]}
    return {"name": "Not Found", "pada": "N/A", "ruler": "N/A"}

def print_nakshatras(subject: AstrologicalSubject, chart_type: str):
    if not subject: print(f"Cannot print Nakshatras for {chart_type}, subject is None."); return
    if subject.zodiac_type != "Sidereal": print(f"Warning: Nakshatras require Sidereal zodiac. Current type: {subject.zodiac_type}")
    print(f"\n--- {chart_type} Nakshatra Positions (Method: User Boundaries / User Pada Logic) ---")
    points_of_interest_nak = [ ("Ascendant", "ascendant"), ("MC", "mc"), ("Sun", "sun"), ("Moon", "moon"), ("Mercury", "mercury"), ("Venus", "venus"), ("Mars", "mars"), ("Jupiter", "jupiter"), ("Saturn", "saturn"), ("Uranus", "uranus"), ("Neptune", "neptune"), ("Pluto", "pluto"), ("True Node", "true_node"), ("True S. Node", "true_south_node"), ]
    for point_name, attr_name in points_of_interest_nak:
        nak_name, nak_pada, nak_lord = "N/A", "N/A", "N/A"; sign, pos_in_sign_str, retrograde = "N/A", "N/A", ""; output_str = f"{point_name:<12}: Point data unavailable."
        try:
            point_obj = getattr(subject, attr_name, None) # Use default None
            if point_obj and hasattr(point_obj, 'position') and hasattr(point_obj, 'sign'):
                pos_in_sign = point_obj.position; sign = point_obj.sign; pos_in_sign_str = f"{pos_in_sign:.2f}"
                if hasattr(point_obj, 'retrograde') and point_obj.retrograde: retrograde = " (R)"
                sign_start_lon = SIGN_START_LONGITUDES.get(sign, None)
                if sign_start_lon is not None:
                    absolute_longitude = sign_start_lon + pos_in_sign
                    nak_info = calculate_nakshatra_from_boundaries(absolute_longitude)
                    nak_name = nak_info.get('name', 'Calc Error'); nak_pada = nak_info.get('pada', 'N/A'); nak_lord = nak_info.get('ruler', 'N/A')
                    output_str = f"{point_name:<12}: {nak_name:<15} (Pada {nak_pada}, Lord: {nak_lord:<8}) [{sign} {pos_in_sign_str}°{retrograde}]"
                else: output_str = f"{point_name:<12}: Unknown Sign '{sign}'             [{sign} {pos_in_sign_str}°{retrograde}]"
            elif point_obj: output_str = f"{point_name:<12}: Position/Sign data unavailable."
            # else: Point object was None or attr not found, print default unavailable msg
        except Exception as e: print(f"Error processing Nakshatra for {point_name} ({attr_name}): {e}"); output_str=f"{point_name:<12}: Error processing Nakshatra."
        print(output_str)
    print("-" * 75)


# --- CUSTOM SPEED CALCULATION FUNCTION (Adapted from User Script) ---
def calculate_custom_speeds(subject_t0: AstrologicalSubject):
    """
    Calculates approximate planetary speeds over a 1-day interval.
    Uses the .position attribute for longitude.
    Args:
        subject_t0: The AstrologicalSubject for the initial time (t0).
    Returns:
        A dictionary of {planet_key: speed_deg_per_day}, or None on failure.
    """
    if not subject_t0:
        print("ERROR (calculate_custom_speeds): Input subject_t0 is None.")
        return None

    try:
        # --- Get Planet Data at Time t0 ---
        planets_t0 = {}
        print(f"\nExtracting planet data for custom speed calculation (t0)...")
        for attr_name in EXPECTED_BODIES_FOR_SPEED:
            if hasattr(subject_t0, attr_name):
                planet_obj = getattr(subject_t0, attr_name)
                dict_key = PLANET_ATTRIBUTE_MAP.get(attr_name, attr_name) # Use consistent map
                if planet_obj is not None and hasattr(planet_obj, 'position'): # Check for position attr
                    planets_t0[dict_key] = planet_obj
                # else: print(f"  - Note: Attribute '{attr_name}' is None or lacks 'position' for t0.")
            # else: print(f"  - Warning: Expected speed attribute '{attr_name}' not found on subject_t0.")

        if not planets_t0:
             print("ERROR (calculate_custom_speeds): Failed to retrieve any valid planet data (with position) for t0.")
             return None

        # --- Calculate Time t1 & Subject t1 ---
        # Ensure t0 has necessary time attributes
        if not all(hasattr(subject_t0, attr) for attr in ['year', 'month', 'day', 'hour', 'minute']):
            print("ERROR (calculate_custom_speeds): subject_t0 missing time attributes.")
            return None

        t0_dt_utc = datetime(subject_t0.year, subject_t0.month, subject_t0.day,
                             subject_t0.hour, subject_t0.minute, 0, tzinfo=timezone.utc)
        t1_dt_utc = t0_dt_utc + timedelta(days=1)

        print(f"Calculating positions for speed check at t1: {t1_dt_utc.strftime('%Y-%m-%d %H:%M')} UTC")
        subject_t1 = AstrologicalSubject(
             subject_t0.name + " +1d", t1_dt_utc.year, t1_dt_utc.month, t1_dt_utc.day,
             t1_dt_utc.hour, t1_dt_utc.minute,
             # Pass necessary parameters from t0
             city=getattr(subject_t0, 'city', None), nation=getattr(subject_t0, 'nation', None),
             lng=getattr(subject_t0, 'lng', None), lat=getattr(subject_t0, 'lat', None),
             tz_str=getattr(subject_t0, 'tz_str', None),
             # Use settings from t0
             zodiac_type=getattr(subject_t0, 'zodiac_type', 'Tropical'),
             sidereal_mode=getattr(subject_t0, 'sidereal_mode', 'LAHIRI'),
             houses_system_identifier=getattr(subject_t0, 'houses_system_identifier', 'P'),
             # Use global online mode setting
             online=KERYKEION_ONLINE_MODE
        )
        # print("Created AstrologicalSubject instance for t1.")

        # --- Get Planet Data at Time t1 ---
        planets_t1 = {}
        # print(f"\nExtracting planet data for t1...") # Less verbose
        for attr_name in EXPECTED_BODIES_FOR_SPEED:
             if hasattr(subject_t1, attr_name):
                  planet_obj = getattr(subject_t1, attr_name)
                  dict_key = PLANET_ATTRIBUTE_MAP.get(attr_name, attr_name)
                  if planet_obj is not None and hasattr(planet_obj, 'position'):
                      planets_t1[dict_key] = planet_obj
             # else: print(f"  - Warning: Expected speed attribute '{attr_name}' not found on subject_t1.")

        if not planets_t1:
             print("ERROR (calculate_custom_speeds): Failed to retrieve any valid planet data (with position) for t1.")
             # Consider cleanup if needed: del subject_t1
             return None

        # --- Calculate Speeds ---
        calculated_speeds = {}
        print("\nCalculating custom speeds (deg/day based on t0/t1 positions)...")
        for planet_key, planet_t0_obj in planets_t0.items():
            planet_t1_obj = planets_t1.get(planet_key)
            if not planet_t1_obj:
                # print(f"  - Data for {planet_key} missing at t1. Skipping.")
                continue

            # Use 'position' which is absolute longitude in kerykeion planet objects
            # (Assuming kerykeion >= 0.4 where position is directly the abs longitude)
            lon0 = getattr(planet_t0_obj, 'position', None)
            lon1 = getattr(planet_t1_obj, 'position', None)

            if lon0 is None or lon1 is None:
                # print(f"  - 'position' attribute missing for {planet_key}. Skipping.")
                continue
            if not isinstance(lon0, (int, float)) or not isinstance(lon1, (int, float)):
                # print(f"  - 'position' not numeric for {planet_key}. Skipping.")
                continue

            # Speed calculation logic (Handles 360 deg wrap-around)
            delta_lon = lon1 - lon0
            if delta_lon > 180: delta_lon -= 360.0
            elif delta_lon < -180: delta_lon += 360.0

            calculated_speeds[planet_key] = delta_lon
            # Optional: Compare with built-in speed if available
            # speed_attr_t0 = getattr(planet_t0_obj, 'speed', None)
            # print(f"  - {planet_key:<12}: {delta_lon:+.4f} deg/day", end="")
            # if speed_attr_t0 is not None: print(f" (Kerykeion speed={speed_attr_t0:+.4f})")
            # else: print()

        # Cleanup temporary object
        del subject_t1

        if not calculated_speeds:
             print("\nERROR (calculate_custom_speeds): No speeds were calculated.")
             return None

        print("Custom speed calculation finished.")
        return calculated_speeds

    except Exception as e:
        print(f"ERROR during custom speed calculation: {e}")
        import traceback
        traceback.print_exc()
        return None


# --- ASPECT CALCULATION FUNCTION (Using Custom Speeds) ---
def print_manual_transit_aspects(natal_subject: AstrologicalSubject, transit_subject: AstrologicalSubject, aspects_list: list, max_orb: float, planets_for_aspects: list):
    """Calculates and prints aspects using CUSTOM calculated speeds for transits."""
    if not natal_subject or not transit_subject:
        print("\nCannot calculate transit aspects: Natal or Transit subject missing.")
        return

    print("\n" + "="*30); print(f"   TRANSIT ASPECTS TO NATAL (Using Custom Speed Calc)"); print(f"   (Max Orb: {max_orb:.1f}°, Aspects: {aspects_list})"); print("="*30)

    # --- Calculate Transit Speeds using Custom Function ---
    calculated_transit_speeds = calculate_custom_speeds(transit_subject)
    if not calculated_transit_speeds:
        print("ERROR: Failed to calculate custom transit speeds. Aborting aspect calculation.")
        return

    # --- Prepare Natal and Transit Planet Data ---
    natal_planets = {} # {planet_key: abs_longitude}
    transit_planets = {} # {planet_key: {'lon': abs_longitude, 'speed': custom_speed}}
    aspects_found = []

    # Populate Natal Data (only need longitude)
    print("\nExtracting planet data for aspect calculation...")
    for planet_key in planets_for_aspects: # Use the list defined for aspects
        attr_name = next((attr for attr, key in PLANET_ATTRIBUTE_MAP.items() if key == planet_key), None)
        if not attr_name: continue # Skip if no attribute name mapped

        try:
            n_planet = getattr(natal_subject, attr_name, None)
            if n_planet and hasattr(n_planet, 'sign') and hasattr(n_planet, 'position'):
                sign_start_lon = SIGN_START_LONGITUDES.get(n_planet.sign)
                if sign_start_lon is not None:
                    abs_lon = (sign_start_lon + n_planet.position) % 360
                    natal_planets[planet_key] = abs_lon
                    # print(f"  - Natal {planet_key} Lon: {abs_lon:.2f}")
        except Exception as e: print(f"  - Error getting natal {planet_key}: {e}")

    # Populate Transit Data (longitude + CUSTOM speed)
    for planet_key in planets_for_aspects: # Use the list defined for aspects
        attr_name = next((attr for attr, key in PLANET_ATTRIBUTE_MAP.items() if key == planet_key), None)
        if not attr_name: continue

        try:
            t_planet = getattr(transit_subject, attr_name, None)
            if t_planet and hasattr(t_planet, 'sign') and hasattr(t_planet, 'position'):
                sign_start_lon = SIGN_START_LONGITUDES.get(t_planet.sign)
                if sign_start_lon is not None:
                    abs_lon = (sign_start_lon + t_planet.position) % 360
                    # *** GET CUSTOM SPEED ***
                    # Use the planet_key ('Sun', 'Moon') to look up in calculated speeds
                    custom_speed = calculated_transit_speeds.get(planet_key)

                    # Only add if speed was successfully calculated
                    if custom_speed is not None:
                         transit_planets[planet_key] = {'lon': abs_lon, 'speed': custom_speed}
                         # print(f"  - Transit {planet_key} Lon: {abs_lon:.2f}, Custom Speed: {custom_speed:+.4f}")
                    # else: print(f"  - Note: Custom speed not found for Transit {planet_key}.")

        except Exception as e: print(f"  - Error getting transit {planet_key}: {e}")

    # --- Check if data is sufficient ---
    if not natal_planets or not transit_planets:
        print("Error: Insufficient planet data (natal longitudes or transit lon/custom speeds) to calculate aspects.")
        if not natal_planets: print("  Reason: No valid natal planet longitudes collected.")
        if not transit_planets: print("  Reason: No valid transit planet data (lon+custom speed) collected.")
        return

    # --- Calculate Aspects ---
    # print("\nCalculating aspects with custom speeds...")
    for tp_name, tp_data in transit_planets.items():
        for np_name, np_lon in natal_planets.items():
            tp_lon = tp_data['lon']
            tp_speed = tp_data['speed'] # This is now the CUSTOM speed

            raw_diff = tp_lon - np_lon

            for aspect_angle in aspects_list:
                delta = (raw_diff - aspect_angle + 540) % 360 - 180
                orb = abs(delta)

                if orb <= max_orb:
                    aspect_name = ASPECT_NAMES.get(aspect_angle, f"{aspect_angle}°")
                    status = "Exact/Stationary"

                    if abs(tp_speed) > 1e-7: # Check if not effectively stationary
                        if tp_speed > 0: is_applying = (delta <= 0)
                        else: is_applying = (delta >= 0)
                        status = "Applying" if is_applying else "Separating"

                    aspects_found.append({
                        'tp_name': tp_name, 'aspect_name': aspect_name, 'np_name': np_name,
                        'orb': orb, 'status': status
                    })

    # --- Print Results ---
    if not aspects_found:
        print("\nNo significant aspects found within the specified orb using custom speeds.")
        return

    aspects_found.sort(key=lambda x: x['orb'])
    print(f"\n{'Transit Planet':<15} {'Aspect':<12} {'Natal Planet':<15} {'Orb':<8} {'Status'}")
    print("-" * 60)
    for aspect in aspects_found:
        orb_str = f"{aspect['orb']:.2f}°"
        print(f"{aspect['tp_name']:<15} {aspect['aspect_name']:<12} {aspect['np_name']:<15} {orb_str:<8} {aspect['status']}")
    print("-" * 60)


# --- MAIN EXECUTION ---
if __name__ == "__main__":

    # --- Calculate UTC Times ---
    print("Calculating UTC times...")
    natal_utc_dt = get_utc_datetime( natal_year, natal_month, natal_day, natal_hour_local, natal_minute_local, location_timezone_str)
    transit_utc_dt = get_utc_datetime( transit_year, transit_month, transit_day, transit_hour_local, transit_minute_local, location_timezone_str)
    if not natal_utc_dt or not transit_utc_dt:
        print("Error: Could not calculate required UTC times. Exiting."); exit(1)

    # --- Create Astrological Subjects ---
    print("\nCreating AstrologicalSubject instances...")
    natal_subject = None; transit_subject = None
    try:
        natal_subject = AstrologicalSubject(
             name=natal_name, year=natal_utc_dt.year, month=natal_utc_dt.month, day=natal_utc_dt.day,
             hour=natal_utc_dt.hour, minute=natal_utc_dt.minute, city=location_city, nation=location_nation,
             lat=location_latitude, lng=location_longitude, tz_str=location_timezone_str,
             zodiac_type=zodiac_type, sidereal_mode=ayanamsa, houses_system_identifier=house_system_identifier,
             online=KERYKEION_ONLINE_MODE
        )
        print(f"- Successfully created: {natal_subject.name}")
    except Exception as e: print(f"Error creating Natal AstrologicalSubject: {e}"); import traceback; traceback.print_exc()

    try:
        transit_subject = AstrologicalSubject(
             name=transit_name, year=transit_utc_dt.year, month=transit_utc_dt.month, day=transit_utc_dt.day,
             hour=transit_utc_dt.hour, minute=transit_utc_dt.minute, city=location_city, nation=location_nation,
             lat=location_latitude, lng=location_longitude, tz_str=location_timezone_str,
             zodiac_type=zodiac_type, sidereal_mode=ayanamsa, houses_system_identifier=house_system_identifier,
             online=KERYKEION_ONLINE_MODE
        )
        print(f"- Successfully created: {transit_subject.name}")
    except Exception as e: print(f"Error creating Transit AstrologicalSubject: {e}"); import traceback; traceback.print_exc()

    # --- Generate and Print Reports ---
    if natal_subject:
        print("\n" + "="*30); print(f"   NATAL CHART REPORT: {natal_name}"); print(f"   (Using {house_system_name} Houses, {ayanamsa} Ayanamsa)"); print("="*30)
        try:
            natal_report = Report(natal_subject); natal_report.print_report(); print("-" * 70)
            print_nakshatras(natal_subject, "Natal")
        except Exception as e: print(f"\nError generating Natal Report or Nakshatras: {e}")
    else: print("\nSkipping Natal Report (Subject creation failed).")

    if transit_subject:
        print("\n" + "="*30); print(f"   TRANSIT CHART REPORT: {transit_name}"); print(f"   (Using {house_system_name} Houses, {ayanamsa} Ayanamsa)"); print("="*30)
        try:
            transit_report = Report(transit_subject); transit_report.print_report(); print("-" * 70)
            print_nakshatras(transit_subject, "Transit")
        except Exception as e: print(f"\nError generating Transit Report or Nakshatras: {e}")
    else: print("\nSkipping Transit Report (Subject creation failed).")

    # --- Print Transit Aspects (Using CUSTOM Speed Calculation) ---
    if natal_subject and transit_subject:
        print_manual_transit_aspects(natal_subject, transit_subject, ASPECTS_TO_CHECK, MAX_ASPECT_ORB, PLANETS_FOR_ASPECTS)
    else:
        print("\nSkipping Transit Aspect calculation (Natal or Transit subject missing).")

    print("\nScript finished.")
